#pragma once

#include "src/3d/3d.hpp"
#include "src/assertions.hpp"

#include <cstddef>
#include <stdexcept>
#include <vector>
#include <limits>
#include <cstdint>

namespace OpenSim {
    class Component;
    class ModelDisplayHints;
}

namespace SimTK {
    class State;
}

namespace osc {
    // 3D drawlist generated from an OpenSim::Component
    //
    // associates each geometry instance in the drawlist with each (sub-)Component
    // that generated the geometry
    class Component_drawlist final {
        friend void optimize(Component_drawlist&) noexcept;

        // these two are 1:1 associated
        //
        // each instance in the "raw" Drawlist was generated by calling
        // .generateDecorations on some Component.
        Drawlist drawlist;
        std::vector<OpenSim::Component const*> associated_components;

    public:
        // clear all data in the drawlist
        //
        // shouldn't deallocate any memory, so that the memory can be recycled
        // between frames
        void clear() {
            drawlist.clear();
            associated_components.clear();
        }

        // push an instance (+ associated component) into the drawlist
        void push_back(OpenSim::Component const* c, Mesh_instance const& mi) {
            size_t idx = associated_components.size();

            if (idx >= std::numeric_limits<uint16_t>::max()) {
                throw std::runtime_error{
                    "precondition error: tried to render more than the maximum number of components that osc can render"};
            }


            uint16_t passthrough_id = static_cast<uint16_t>(idx + 1);

            Mesh_instance copy = mi;
            copy.passthrough.assign_u16(passthrough_id);

            associated_components.emplace_back(c);
            drawlist.push_back(copy);
        }

        // decode a component from passthrough data
        OpenSim::Component const* component_from_passthrough(Passthrough_data d) {
            uint16_t passthrough_id = d.get_u16();

            if (passthrough_id > 0) {
                return associated_components[passthrough_id - 1];
            } else {
                return nullptr;
            }
        }

        template<typename Callback>
        void for_each(Callback f) {
            // emplace-back ensures this
            OSC_ASSERT(drawlist.size() == associated_components.size());

            drawlist.for_each([&](Mesh_instance& mi) {
                uint16_t id = mi.passthrough.get_u16();
                OSC_ASSERT(id != 0 && "zero ID inserted into drawlist (emplace_back should prevent this)");
                f(associated_components[id - 1], mi);
            });
        }

        template<typename Callback>
        void for_each_component(Callback f) {
            for (OpenSim::Component const*& c : associated_components) {
                f(c);
            }
        }

        Drawlist const& raw_drawlist() const noexcept {
            return drawlist;
        }

        Drawlist& raw_drawlist() noexcept {
            return drawlist;
        }
    };

    inline void optimize(Component_drawlist& mdl) noexcept {
        optimize(mdl.drawlist);
    }

    using ModelDrawlistFlags = int;
    enum ModelDrawlistFlags_ {
        ModelDrawlistFlags_None = 0,
        ModelDrawlistFlags_StaticGeometry = 1 << 0,
        ModelDrawlistFlags_DynamicGeometry = 1 << 2,
        ModelDrawlistFlags_Default = ModelDrawlistFlags_StaticGeometry | ModelDrawlistFlags_DynamicGeometry,
    };

    void generate_component_decorations(
        OpenSim::Component const&,
        SimTK::State const&,
        OpenSim::ModelDisplayHints const&,
        GPU_storage&,
        Component_drawlist&,
        ModelDrawlistFlags = ModelDrawlistFlags_Default);
}
