// The reason <Python.h> is included this way is because Visual Studio will
// look for (e.g.) `python313_d.lib` if building in debug mode, which won't
// work for typical installs of python
#ifdef _DEBUG
    #undef _DEBUG
    #include <Python.h>
    #define _DEBUG
#else
    #include <Python.h>
#endif

#include <cstdlib>
#include <fstream>
#include <sstream>
#include <string>

#if defined(_WIN32)
    #include <direct.h>
    #define chdir _chdir
#else
    #include <unistd.h>
#endif

namespace
{
    std::string read_file(const std::string& path)
    {
        std::ifstream file(path, std::ios::binary); // binary avoids newline translation
        if (!file) throw std::runtime_error("Cannot open file: " + path);

        std::ostringstream buffer;
        buffer << file.rdbuf();
        return buffer.str();
    }
}

int main() {
    // Set working directory to the debugger root directory
    if (chdir("@CMAKE_CURRENT_SOURCE_DIR@") != 0) {
        perror("chdir failed");
        return 1;
    }

    // Set PYTHONPATH so that Python finds the `opynsim` package
#if defined(_WIN32)
    _putenv("PYTHONPATH=@CMAKE_CURRENT_SOURCE_DIR@/..");
#else
    setenv("PYTHONPATH", "@CMAKE_CURRENT_SOURCE_DIR@/..", 1);
#endif

    // This is roughly equivalent to running `python debugscript.py` in the terminal
    Py_Initialize();

    std::string code = read_file("@CMAKE_CURRENT_SOURCE_DIR@/debugscript.py");
    int result = PyRun_SimpleString(code.c_str());
    Py_Finalize();
    return result;
}
