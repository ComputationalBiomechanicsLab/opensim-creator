This patch removes some invalid typedefs/casts in simbody that gcc's
`-Warray-bounds` warning can pick up on.

---

diff --git a/third_party/libosim/simbody/SimTKcommon/CMakeLists.txt b/third_party/libosim/simbody/SimTKcommon/CMakeLists.txt
index 6a6d7749..8798b67b 100644
--- a/third_party/libosim/simbody/SimTKcommon/CMakeLists.txt
+++ b/third_party/libosim/simbody/SimTKcommon/CMakeLists.txt
@@ -145,7 +145,7 @@ target_compile_definitions(SimTKcommon
 # (maintaining intent of previous behavior, but more universally applied and effective)
 # See https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#language-standard-flags
 # for info re: ordering of the compiler flag(s) for language standards and CMAKE_<LANG>_FLAGS
-target_compile_features(SimTKcommon PUBLIC cxx_std_11)
+target_compile_features(SimTKcommon PUBLIC cxx_std_17)
 
 # Warning 4996 is not propagated to downstream targets
 target_compile_options(SimTKcommon INTERFACE
diff --git a/third_party/libosim/simbody/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Mat.h b/third_party/libosim/simbody/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Mat.h
index 22b0439d..f4234bf3 100644
--- a/third_party/libosim/simbody/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Mat.h
+++ b/third_party/libosim/simbody/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Mat.h
@@ -30,6 +30,9 @@
 
 #include "SimTKcommon/internal/common.h"
 
+#include <tuple>
+#include <type_traits>
+
 namespace SimTK {
 
 /** @brief This class represents a small matrix whose size is known at compile 
@@ -376,71 +379,21 @@ public:
     explicit Mat(int i) 
       { new (this) Mat(E(Precision(i))); }
 
-    // A bevy of constructors from individual exact-match elements IN ROW ORDER.
-    Mat(const E& e0,const E& e1)
-      {assert(M*N==2);d[rIx(0)]=e0;d[rIx(1)]=e1;}
-    Mat(const E& e0,const E& e1,const E& e2)
-      {assert(M*N==3);d[rIx(0)]=e0;d[rIx(1)]=e1;d[rIx(2)]=e2;}
-    Mat(const E& e0,const E& e1,const E& e2,const E& e3)
-      {assert(M*N==4);d[rIx(0)]=e0;d[rIx(1)]=e1;d[rIx(2)]=e2;d[rIx(3)]=e3;}
-    Mat(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4)
-      {assert(M*N==5);d[rIx(0)]=e0;d[rIx(1)]=e1;d[rIx(2)]=e2;d[rIx(3)]=e3;d[rIx(4)]=e4;}
-    Mat(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4,
-        const E& e5)
-      {assert(M*N==6);d[rIx(0)]=e0;d[rIx(1)]=e1;d[rIx(2)]=e2;d[rIx(3)]=e3;d[rIx(4)]=e4;
-       d[rIx(5)]=e5;}
-    Mat(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4,
-        const E& e5,const E& e6)
-      {assert(M*N==7);d[rIx(0)]=e0;d[rIx(1)]=e1;d[rIx(2)]=e2;d[rIx(3)]=e3;d[rIx(4)]=e4;
-       d[rIx(5)]=e5;d[rIx(6)]=e6;}
-    Mat(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4,
-        const E& e5,const E& e6,const E& e7)
-      {assert(M*N==8);d[rIx(0)]=e0;d[rIx(1)]=e1;d[rIx(2)]=e2;d[rIx(3)]=e3;d[rIx(4)]=e4;
-       d[rIx(5)]=e5;d[rIx(6)]=e6;d[rIx(7)]=e7;}
-    Mat(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4,
-        const E& e5,const E& e6,const E& e7,const E& e8)
-      {assert(M*N==9);d[rIx(0)]=e0;d[rIx(1)]=e1;d[rIx(2)]=e2;d[rIx(3)]=e3;d[rIx(4)]=e4;
-       d[rIx(5)]=e5;d[rIx(6)]=e6;d[rIx(7)]=e7;d[rIx(8)]=e8;}
-    Mat(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4,
-        const E& e5,const E& e6,const E& e7,const E& e8,const E& e9)
-      {assert(M*N==10);d[rIx(0)]=e0;d[rIx(1)]=e1;d[rIx(2)]=e2;d[rIx(3)]=e3;d[rIx(4)]=e4;
-       d[rIx(5)]=e5;d[rIx(6)]=e6;d[rIx(7)]=e7;d[rIx(8)]=e8;d[rIx(9)]=e9;}
-    Mat(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4,
-        const E& e5,const E& e6,const E& e7,const E& e8,const E& e9,
-        const E& e10)
-      {assert(M*N==11);d[rIx(0)]=e0;d[rIx(1)]=e1;d[rIx(2)]=e2;d[rIx(3)]=e3;d[rIx(4)]=e4;
-       d[rIx(5)]=e5;d[rIx(6)]=e6;d[rIx(7)]=e7;d[rIx(8)]=e8;d[rIx(9)]=e9;d[rIx(10)]=e10;}
-    Mat(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4,
-        const E& e5,const E& e6,const E& e7,const E& e8,const E& e9,
-        const E& e10, const E& e11)
-      {assert(M*N==12);d[rIx(0)]=e0;d[rIx(1)]=e1;d[rIx(2)]=e2;d[rIx(3)]=e3;d[rIx(4)]=e4;
-       d[rIx(5)]=e5;d[rIx(6)]=e6;d[rIx(7)]=e7;d[rIx(8)]=e8;d[rIx(9)]=e9;d[rIx(10)]=e10;
-       d[rIx(11)]=e11;}
-    Mat(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4,
-        const E& e5,const E& e6,const E& e7,const E& e8,const E& e9,
-        const E& e10, const E& e11, const E& e12)
-      {assert(M*N==13);d[rIx(0)]=e0;d[rIx(1)]=e1;d[rIx(2)]=e2;d[rIx(3)]=e3;d[rIx(4)]=e4;
-       d[rIx(5)]=e5;d[rIx(6)]=e6;d[rIx(7)]=e7;d[rIx(8)]=e8;d[rIx(9)]=e9;d[rIx(10)]=e10;
-       d[rIx(11)]=e11;d[rIx(12)]=e12;}
-    Mat(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4,
-        const E& e5,const E& e6,const E& e7,const E& e8,const E& e9,
-        const E& e10, const E& e11, const E& e12, const E& e13)
-      {assert(M*N==14);d[rIx(0)]=e0;d[rIx(1)]=e1;d[rIx(2)]=e2;d[rIx(3)]=e3;d[rIx(4)]=e4;
-       d[rIx(5)]=e5;d[rIx(6)]=e6;d[rIx(7)]=e7;d[rIx(8)]=e8;d[rIx(9)]=e9;d[rIx(10)]=e10;
-       d[rIx(11)]=e11;d[rIx(12)]=e12;d[rIx(13)]=e13;}
-    Mat(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4,
-        const E& e5,const E& e6,const E& e7,const E& e8,const E& e9,
-        const E& e10, const E& e11, const E& e12, const E& e13, const E& e14)
-      {assert(M*N==15);d[rIx(0)]=e0;d[rIx(1)]=e1;d[rIx(2)]=e2;d[rIx(3)]=e3;d[rIx(4)]=e4;
-       d[rIx(5)]=e5;d[rIx(6)]=e6;d[rIx(7)]=e7;d[rIx(8)]=e8;d[rIx(9)]=e9;d[rIx(10)]=e10;
-       d[rIx(11)]=e11;d[rIx(12)]=e12;d[rIx(13)]=e13;d[rIx(14)]=e14;}
-    Mat(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4,
-        const E& e5,const E& e6,const E& e7,const E& e8,const E& e9,
-        const E& e10, const E& e11, const E& e12, const E& e13, const E& e14, 
-        const E& e15)
-      {assert(M*N==16);d[rIx(0)]=e0;d[rIx(1)]=e1;d[rIx(2)]=e2;d[rIx(3)]=e3;d[rIx(4)]=e4;
-       d[rIx(5)]=e5;d[rIx(6)]=e6;d[rIx(7)]=e7;d[rIx(8)]=e8;d[rIx(9)]=e9;d[rIx(10)]=e10;
-       d[rIx(11)]=e11;d[rIx(12)]=e12;d[rIx(13)]=e13;d[rIx(14)]=e14;d[rIx(15)]=e15;}
+    // Constructs a `Mat` from individual exact-match elements IN ROW ORDER.
+    template<
+        typename... Elements,
+        typename = std::enable_if_t<
+            (M*N==sizeof...(Elements)) &&
+            (std::is_convertible_v<Elements&&, const E&> && ...)
+        >
+    >
+    Mat(Elements&&... elementsRowByRow)
+    {
+        assignDataRowByRow(
+            std::forward_as_tuple(elementsRowByRow...),
+            std::make_integer_sequence<int, sizeof...(Elements)>{}
+        );
+    }
 
     // Construction from 1-6 *exact match* Rows
     explicit Mat(const TRow& r0)
@@ -1238,6 +1191,12 @@ private:
         const int col = k % N; // that's modulus, not cross product!
         return row*RS + col*CS;
     }
+
+    template<typename ElementsRowByRowTuple, int... Idx>
+    void assignDataRowByRow(ElementsRowByRowTuple&& els, std::integer_sequence<int, Idx...>)
+    {
+        ((d[rIx(Idx)] = std::get<Idx>(els)) , ...);
+    }
 };
 
 //////////////////////////////////////////////
diff --git a/third_party/libosim/simbody/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Row.h b/third_party/libosim/simbody/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Row.h
index 9724fad9..43f1b033 100644
--- a/third_party/libosim/simbody/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Row.h
+++ b/third_party/libosim/simbody/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Row.h
@@ -160,7 +160,7 @@ public:
         NRows               = 1,
         NCols               = N,
         NPackedElements     = N,
-        NActualElements     = N * STRIDE,   // includes trailing gap
+        NActualElements     = (N * STRIDE) - (STRIDE - 1),  // no trailing gap
         NActualScalars      = CNT<E>::NActualScalars * NActualElements,
         RowSpacing          = NActualElements,
         ColSpacing          = STRIDE,
diff --git a/third_party/libosim/simbody/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Vec.h b/third_party/libosim/simbody/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Vec.h
index d863a8f2..405aec36 100644
--- a/third_party/libosim/simbody/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Vec.h
+++ b/third_party/libosim/simbody/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Vec.h
@@ -239,7 +239,7 @@ public:
         NRows               = M,
         NCols               = 1,
         NPackedElements     = M,
-        NActualElements     = M * STRIDE,   // includes trailing gap
+        NActualElements     = (M * STRIDE) - (STRIDE-1),  // no trailing gap
         NActualScalars      = CNT<E>::NActualScalars * NActualElements,
         RowSpacing          = STRIDE,
         ColSpacing          = NActualElements,
