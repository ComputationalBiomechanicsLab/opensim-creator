Makes various constructors in SimTK::Vec and SimTK::CoordinateAxis/CoordinateDirection
constexpr in order to reduce the amount of initialization order issues in the
codebase.

---
diff --git a/SimTKcommon/Geometry/include/SimTKcommon/internal/DecorativeGeometry.h b/SimTKcommon/Geometry/include/SimTKcommon/internal/DecorativeGeometry.h
index 036399c0f..56550b481 100644
--- a/SimTKcommon/Geometry/include/SimTKcommon/internal/DecorativeGeometry.h
+++ b/SimTKcommon/Geometry/include/SimTKcommon/internal/DecorativeGeometry.h
@@ -36,17 +36,18 @@ Declarations of DecorativeGeometry and related derived classes. **/
 namespace SimTK {
 
 // Some common RGB values;
-extern SimTK_SimTKCOMMON_EXPORT const Vec3 Black;   ///< RGB=( 0, 0, 0)
-extern SimTK_SimTKCOMMON_EXPORT const Vec3 Gray;    ///< RGB=(.5,.5,.5)
-extern SimTK_SimTKCOMMON_EXPORT const Vec3 Red;     ///< RGB=( 1, 0, 0)
-extern SimTK_SimTKCOMMON_EXPORT const Vec3 Green;   ///< RGB=( 0, 1, 0)
-extern SimTK_SimTKCOMMON_EXPORT const Vec3 Blue;    ///< RGB=( 0, 0, 1)
-extern SimTK_SimTKCOMMON_EXPORT const Vec3 Yellow;  ///< RGB=( 1, 1, 0)
-extern SimTK_SimTKCOMMON_EXPORT const Vec3 Orange;  ///< RGB=( 1,.5, 0)
-extern SimTK_SimTKCOMMON_EXPORT const Vec3 Magenta; ///< RGB=( 1, 0, 1)
-extern SimTK_SimTKCOMMON_EXPORT const Vec3 Purple;  ///< RGB=(.5, 0,.5)
-extern SimTK_SimTKCOMMON_EXPORT const Vec3 Cyan;    ///< RGB=( 0, 1, 1)
-extern SimTK_SimTKCOMMON_EXPORT const Vec3 White;   ///< RGB=( 1, 1, 1)
+
+constexpr Vec3 Black   = Vec3( 0, 0, 0);
+constexpr Vec3 Gray    = Vec3(.5,.5,.5);
+constexpr Vec3 Red     = Vec3( 1, 0, 0);
+constexpr Vec3 Green   = Vec3( 0, 1, 0);
+constexpr Vec3 Blue    = Vec3( 0, 0, 1);
+constexpr Vec3 Yellow  = Vec3( 1, 1, 0);
+constexpr Vec3 Orange  = Vec3( 1,.5, 0);
+constexpr Vec3 Magenta = Vec3( 1, 0, 1);
+constexpr Vec3 Purple  = Vec3(.5, 0,.5);
+constexpr Vec3 Cyan    = Vec3( 0, 1, 1);
+constexpr Vec3 White   = Vec3( 1, 1, 1);
 
 // Drawing representations
 
diff --git a/SimTKcommon/Geometry/src/DecorativeGeometry.cpp b/SimTKcommon/Geometry/src/DecorativeGeometry.cpp
index cdbefe85a..f8f63124d 100644
--- a/SimTKcommon/Geometry/src/DecorativeGeometry.cpp
+++ b/SimTKcommon/Geometry/src/DecorativeGeometry.cpp
@@ -34,18 +34,6 @@ namespace SimTK {
 // Some common RGB values; these constants are global external symbols exported
 // by the library, defined as externs in DecorativeGeometry.h.
 
-const Vec3 Black   = Vec3( 0, 0, 0);
-const Vec3 Gray    = Vec3(.5,.5,.5);
-const Vec3 Red     = Vec3( 1, 0, 0);
-const Vec3 Green   = Vec3( 0, 1, 0);
-const Vec3 Blue    = Vec3( 0, 0, 1);
-const Vec3 Yellow  = Vec3( 1, 1, 0);
-const Vec3 Orange  = Vec3( 1,.5, 0);
-const Vec3 Magenta = Vec3( 1, 0, 1);
-const Vec3 Purple  = Vec3(.5, 0,.5);
-const Vec3 Cyan    = Vec3( 0, 1, 1);
-const Vec3 White   = Vec3( 1, 1, 1);
-
     /////////////////////////
     // DECORATIVE GEOMETRY //
     /////////////////////////
diff --git a/SimTKcommon/Mechanics/include/SimTKcommon/internal/CoordinateAxis.h b/SimTKcommon/Mechanics/include/SimTKcommon/internal/CoordinateAxis.h
index 45de1fb85..efaf8cdf0 100644
--- a/SimTKcommon/Mechanics/include/SimTKcommon/internal/CoordinateAxis.h
+++ b/SimTKcommon/Mechanics/include/SimTKcommon/internal/CoordinateAxis.h
@@ -180,9 +180,9 @@ protected:
     class YTypeAxis{};
     class ZTypeAxis{};
 
-    CoordinateAxis( const XTypeAxis& ) : m_myAxisId(0) {}
-    CoordinateAxis( const YTypeAxis& ) : m_myAxisId(1) {}
-    CoordinateAxis( const ZTypeAxis& ) : m_myAxisId(2) {}
+    constexpr CoordinateAxis( const XTypeAxis& ) : m_myAxisId(0) {}
+    constexpr CoordinateAxis( const YTypeAxis& ) : m_myAxisId(1) {}
+    constexpr CoordinateAxis( const ZTypeAxis& ) : m_myAxisId(2) {}
     /** @endcond **/
 private:            
 
@@ -192,24 +192,27 @@ private:
 
 // Helper classes that allow compile time recognition of axis directions.
 class CoordinateAxis::XCoordinateAxis : public CoordinateAxis {
-  public: XCoordinateAxis() : CoordinateAxis(XTypeAxis()) {}
+public:
+    constexpr XCoordinateAxis() : CoordinateAxis(XTypeAxis()) {}
 };
 class CoordinateAxis::YCoordinateAxis : public CoordinateAxis {
-  public: YCoordinateAxis() : CoordinateAxis(YTypeAxis()) {}
+public:
+    constexpr YCoordinateAxis() : CoordinateAxis(YTypeAxis()) {}
 };
 class CoordinateAxis::ZCoordinateAxis : public CoordinateAxis {
-  public: ZCoordinateAxis() : CoordinateAxis(ZTypeAxis()) {}
+public:
+    constexpr ZCoordinateAxis() : CoordinateAxis(ZTypeAxis()) {}
 };
 
 /** Constant representing the X coordinate axis; will implicitly convert to
 the integer 0 when used in a context requiring an integer. **/
-extern SimTK_SimTKCOMMON_EXPORT const CoordinateAxis::XCoordinateAxis  XAxis;
+constexpr CoordinateAxis::XCoordinateAxis  XAxis;
 /** Constant representing the Y coordinate axis; will implicitly convert to
 the integer 1 when used in a context requiring an integer. **/
-extern SimTK_SimTKCOMMON_EXPORT const CoordinateAxis::YCoordinateAxis  YAxis;
+constexpr CoordinateAxis::YCoordinateAxis  YAxis;
 /** Constant representing the Z coordinate axis; will implicitly convert to
 the integer 2 when used in a context requiring an integer. **/
-extern SimTK_SimTKCOMMON_EXPORT const CoordinateAxis::ZCoordinateAxis  ZAxis;
+constexpr CoordinateAxis::ZCoordinateAxis  ZAxis;
 
 inline const CoordinateAxis& CoordinateAxis::getCoordinateAxis(int i) {
     assert(isIndexInRange(i));
@@ -249,12 +252,12 @@ public:
 
     /** Implicit conversion of a CoordinateAxis to a positive 
     CoordinateDirection along that axis. **/
-    CoordinateDirection(const CoordinateAxis& axis)
+    constexpr CoordinateDirection(const CoordinateAxis& axis)
     :   m_axis(axis), m_direction(1) {}
 
     /** Explicit creation of a negative CoordinateDirection from a 
     CoordinateAxis. **/
-    CoordinateDirection(const CoordinateAxis& axis, Negative)
+    constexpr CoordinateDirection(const CoordinateAxis& axis, Negative)
     :   m_axis(axis), m_direction(-1) {}
 
     /** Explicit creation of a CoordinateDirection from a CoordinateAxis
@@ -336,22 +339,22 @@ private:
 // Helper classes that allow compile time recognition of negative axis
 // directions.
 class CoordinateDirection::NegXDirection : public CoordinateDirection {
-  public: NegXDirection() : CoordinateDirection(XAxis,Negative()) {}
+public:
+    constexpr NegXDirection() : CoordinateDirection(XAxis,Negative()) {}
 };
 class CoordinateDirection::NegYDirection : public CoordinateDirection {
-  public: NegYDirection() : CoordinateDirection(YAxis,Negative()) {}
+public:
+    constexpr NegYDirection() : CoordinateDirection(YAxis,Negative()) {}
 };
 class CoordinateDirection::NegZDirection : public CoordinateDirection {
-  public: NegZDirection() : CoordinateDirection(ZAxis,Negative()) {}
+public:
+    constexpr NegZDirection() : CoordinateDirection(ZAxis,Negative()) {}
 };
 
 // Predefine constants for the negative X,Y,Z directions.
-extern SimTK_SimTKCOMMON_EXPORT const CoordinateDirection::NegXDirection  
-    NegXAxis; ///< Global constant indicating -X coordinate direction.
-extern SimTK_SimTKCOMMON_EXPORT const CoordinateDirection::NegYDirection  
-    NegYAxis; ///< Global constant indicating -Y coordinate direction.
-extern SimTK_SimTKCOMMON_EXPORT const CoordinateDirection::NegZDirection  
-    NegZAxis; ///< Global constant indicating -Z coordinate direction.
+constexpr CoordinateDirection::NegXDirection NegXAxis; ///< Global constant indicating -X coordinate direction.
+constexpr CoordinateDirection::NegYDirection NegYAxis; ///< Global constant indicating -Y coordinate direction.
+constexpr CoordinateDirection::NegZDirection NegZAxis; ///< Global constant indicating -Z coordinate direction.
 
 /// Compare two CoordinateDirection objects. @relates CoordinateDirection 
 inline bool operator==(const CoordinateDirection& d1, 
diff --git a/SimTKcommon/Mechanics/src/CoordinateAxis.cpp b/SimTKcommon/Mechanics/src/CoordinateAxis.cpp
index c4b4191c7..2a7092c47 100644
--- a/SimTKcommon/Mechanics/src/CoordinateAxis.cpp
+++ b/SimTKcommon/Mechanics/src/CoordinateAxis.cpp
@@ -30,18 +30,4 @@
 #include "SimTKcommon/internal/CoordinateAxis.h"
 
 namespace SimTK {
-
-// These constants are global external symbols exported by the library. See
-// the CoordinateAxis.h header file for information.
-const CoordinateAxis::XCoordinateAxis      XAxis;
-const CoordinateAxis::YCoordinateAxis      YAxis;
-const CoordinateAxis::ZCoordinateAxis      ZAxis;
-
-const CoordinateDirection::NegXDirection   NegXAxis;
-const CoordinateDirection::NegYDirection   NegYAxis;
-const CoordinateDirection::NegZDirection   NegZAxis;
-
-
 }  // End of namespace SimTK
-
-
diff --git a/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Vec.h b/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Vec.h
index a30c81905..c5adc6ab6 100644
--- a/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Vec.h
+++ b/SimTKcommon/SmallMatrix/include/SimTKcommon/internal/Vec.h
@@ -422,7 +422,7 @@ public:
     /** Default construction initializes %Vec's elements to NaN when debugging 
     but leaves them uninitialized garbage otherwise, so declarations have zero
     cost in Release builds. **/
-    Vec(){ 
+    constexpr Vec(){
     #ifndef NDEBUG
         setToNaN();
     #endif
@@ -435,45 +435,48 @@ public:
     /** Copy constructor copies the logically-included elements from the
     source %Vec; gaps due to stride are not accessed in either source or
     destination. **/
-    Vec(const Vec& src) {
-        Impl::copy(*this, src);
+    constexpr Vec(const Vec& src) {
+        assignElementsAsRandomAccessRange(src, std::make_integer_sequence<int, M>{});
     }
     /** Copy assignment operator copies the logically-included elements from 
     the source %Vec; gaps due to stride are not accessed in either source or
     destination. OK if source and destination are the same vector; results
     are unpredictable if they otherwise overlap with elements in common. **/
-    Vec& operator=(const Vec& src) {    
-        Impl::copy(*this, src);
+    constexpr Vec& operator=(const Vec& src) {
+        assignElementsAsRandomAccessRange(src, std::make_integer_sequence<int, M>{});
         return *this;
     }
 
     /** This is an implicit conversion from a %Vec of the same length
     and element type but with a different stride. **/
-    template <int SS> Vec(const Vec<M,E,SS>& src) {
-        Impl::copy(*this, src);
+    template <int SS>
+    constexpr Vec(const Vec<M,E,SS>& src) {
+        assignElementsAsRandomAccessRange(src, std::make_integer_sequence<int, M>{});
     }
 
     /** This is an implicit conversion from a %Vec of the same length
     and \e negated element type (possibly with a different stride). **/
-    template <int SS> Vec(const Vec<M,ENeg,SS>& src) {
-        Impl::copy(*this, src);
+    template <int SS>
+    constexpr Vec(const Vec<M,ENeg,SS>& src) {
+        assignElementsAsRandomAccessRange(src, std::make_integer_sequence<int, M>{});
     }
 
     /** Construct a Vec from a Vec of the same length, with any stride. Works 
     as long as the element types are assignment compatible. **/
-    template <class EE, int SS> explicit Vec(const Vec<M,EE,SS>& src) {
-        Impl::copy(*this, src);
+    template <class EE, int SS>
+    explicit constexpr Vec(const Vec<M,EE,SS>& src) {
+        assignElementsAsRandomAccessRange(src, std::make_integer_sequence<int, M>{});
     }
 
     /** Construction from a single value of this %Vec's element type assigns
     that value to each element. **/
-    explicit Vec(const E& e) {for (int i=0;i<M;++i) d[i*STRIDE]=e;}
+    explicit constexpr Vec(const E& e) {for (int i=0;i<M;++i) d[i*STRIDE]=e;}
 
     /** Construction from a single value of this %Vec's negated element type 
     assigns that value to each element, requiring floating point negation
     to be performed once to compute the type-E representation of the 
     type negator<E> value provided. **/
-    explicit Vec(const ENeg& ne) {
+    explicit constexpr Vec(const ENeg& ne) {
         const E e = ne; // requires floating point negation
         for (int i=0;i<M;++i) d[i*STRIDE]=e;
     }
@@ -487,27 +490,14 @@ public:
     // A bevy of constructors for Vecs up to length 9.
 
     /** Construct a Vec<2,E> from two elements of type E, etc. **/
-    Vec(const E& e0,const E& e1)
-      { assert(M==2);(*this)[0]=e0;(*this)[1]=e1; }
-    Vec(const E& e0,const E& e1,const E& e2)
-      { assert(M==3);(*this)[0]=e0;(*this)[1]=e1;(*this)[2]=e2; }
-    Vec(const E& e0,const E& e1,const E& e2,const E& e3)
-      { assert(M==4);(*this)[0]=e0;(*this)[1]=e1;(*this)[2]=e2;(*this)[3]=e3; }
-    Vec(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4)
-      { assert(M==5);(*this)[0]=e0;(*this)[1]=e1;(*this)[2]=e2;
-        (*this)[3]=e3;(*this)[4]=e4; }
-    Vec(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4,const E& e5)
-      { assert(M==6);(*this)[0]=e0;(*this)[1]=e1;(*this)[2]=e2;
-        (*this)[3]=e3;(*this)[4]=e4;(*this)[5]=e5; }
-    Vec(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4,const E& e5, const E& e6)
-      { assert(M==7);(*this)[0]=e0;(*this)[1]=e1;(*this)[2]=e2;
-        (*this)[3]=e3;(*this)[4]=e4;(*this)[5]=e5;(*this)[6]=e6; }
-    Vec(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4,const E& e5, const E& e6, const E& e7)
-      { assert(M==8);(*this)[0]=e0;(*this)[1]=e1;(*this)[2]=e2;
-        (*this)[3]=e3;(*this)[4]=e4;(*this)[5]=e5;(*this)[6]=e6;(*this)[7]=e7; }
-    Vec(const E& e0,const E& e1,const E& e2,const E& e3,const E& e4,const E& e5, const E& e6, const E& e7, const E& e8)
-      { assert(M==9);(*this)[0]=e0;(*this)[1]=e1;(*this)[2]=e2;
-        (*this)[3]=e3;(*this)[4]=e4;(*this)[5]=e5;(*this)[6]=e6;(*this)[7]=e7;(*this)[8]=e8; }
+    constexpr Vec(const E& e0, const E& e1)                                                                                            requires (M == 2) { assignElementsAsTuple(std::make_tuple(e0, e1),                             std::make_integer_sequence<int, M>{}); }
+    constexpr Vec(const E& e0, const E& e1, const E& e2)                                                                               requires (M == 3) { assignElementsAsTuple(std::make_tuple(e0, e1, e2),                         std::make_integer_sequence<int, M>{}); }
+    constexpr Vec(const E& e0, const E& e1, const E& e2, const E& e3)                                                                  requires (M == 4) { assignElementsAsTuple(std::make_tuple(e0, e1, e2, e3),                     std::make_integer_sequence<int, M>{}); }
+    constexpr Vec(const E& e0, const E& e1, const E& e2, const E& e3, const E& e4)                                                     requires (M == 5) { assignElementsAsTuple(std::make_tuple(e0, e1, e2, e3, e4),                 std::make_integer_sequence<int, M>{}); }
+    constexpr Vec(const E& e0, const E& e1, const E& e2, const E& e3, const E& e4, const E& e5)                                        requires (M == 6) { assignElementsAsTuple(std::make_tuple(e0, e1, e2, e3, e4, e5),             std::make_integer_sequence<int, M>{}); }
+    constexpr Vec(const E& e0, const E& e1, const E& e2, const E& e3, const E& e4, const E& e5, const E& e6)                           requires (M == 7) { assignElementsAsTuple(std::make_tuple(e0, e1, e2, e3, e4, e5, e6),         std::make_integer_sequence<int, M>{}); }
+    constexpr Vec(const E& e0, const E& e1, const E& e2, const E& e3, const E& e4, const E& e5, const E& e6, const E& e7)              requires (M == 8) { assignElementsAsTuple(std::make_tuple(e0, e1, e2, e3, e4, e5, e6, e7),     std::make_integer_sequence<int, M>{}); }
+    constexpr Vec(const E& e0, const E& e1, const E& e2, const E& e3, const E& e4, const E& e5, const E& e6, const E& e7, const E& e8) requires (M == 9) { assignElementsAsTuple(std::make_tuple(e0, e1, e2, e3, e4, e5, e6, e7, e8), std::make_integer_sequence<int, M>{}); }
 
     /** Construction from a pointer to elements of any type EE assumes we're 
     pointing at a C++ array of EE's of the right length, and that EE is
@@ -593,17 +583,17 @@ public:
     /** Select an element of this %Vec and return a const reference to it.
     This is range-checked in Debug builds but has zero overhead in Release
     builds. **/
-    const E& operator[](int i) const 
+    constexpr const E& operator[](int i) const
     {   assert(0 <= i && i < M); return d[i*STRIDE]; }
     /** Same as const operator[] above. **/
-    const E& operator()(int i) const {return (*this)[i];}
+    constexpr const E& operator()(int i) const {return (*this)[i];}
 
     /** Select an element of this %Vec and return a writable reference 
     to it. This is range-checked in Debug builds but has zero overhead in 
     Release builds. **/
-    E& operator[](int i) {assert(0 <= i && i < M); return d[i*STRIDE];}
+    constexpr E& operator[](int i) {assert(0 <= i && i < M); return d[i*STRIDE];}
     /** Same as non-const operator[] above. **/
-    E& operator()(int i) {return (*this)[i];}
+    constexpr E& operator()(int i) {return (*this)[i];}
 
     ScalarNormSq normSqr() const { return scalarNormSqr(); }
     typename CNT<ScalarNormSq>::TSqrt 
@@ -1000,6 +990,18 @@ public:
     {   return operator[](i); }
 
 private:
+    template<typename ElementsRowByRowTuple, int... Idx>
+    constexpr void assignElementsAsTuple(ElementsRowByRowTuple&& els, std::integer_sequence<int, Idx...>)
+    {
+        ((d[Idx] = std::get<Idx>(els)) , ...);
+    }
+
+    template<typename R, int... Idx>
+    constexpr void assignElementsAsRandomAccessRange(R&& range, std::integer_sequence<int, Idx...>)
+    {
+        ((d[Idx] = range[Idx]) , ...);
+    }
+
     // TODO: should be an array of scalars rather than elements to control
     // packing more carefully.
     ELT d[NActualElements];    // data
diff --git a/Simbody/Visualizer/src/VisualizerGeometry.cpp b/Simbody/Visualizer/src/VisualizerGeometry.cpp
index e3347ac99..777096488 100644
--- a/Simbody/Visualizer/src/VisualizerGeometry.cpp
+++ b/Simbody/Visualizer/src/VisualizerGeometry.cpp
@@ -28,8 +28,8 @@
 
 using namespace SimTK;
 
-static const Vec3 DefaultBodyColor = Gray;
-static const Vec3 DefaultPointColor = Magenta;
+static constexpr Vec3 DefaultBodyColor = Gray;
+static constexpr Vec3 DefaultPointColor = Magenta;
 
 VisualizerGeometry::VisualizerGeometry
    (VisualizerProtocol& protocol, const SimbodyMatterSubsystem& matter, 
diff --git a/Simbody/src/CableSpan.cpp b/Simbody/src/CableSpan.cpp
index 7f9c78c06..3cea61375 100644
--- a/Simbody/src/CableSpan.cpp
+++ b/Simbody/src/CableSpan.cpp
@@ -111,9 +111,9 @@ Here we define it as (see Scholz2015):
 - Y axis: normal to surface
 - Z axis: binormal to geodesic (tangent cross normal) */
 using FrenetFrame                        = Transform;
-static const CoordinateAxis TangentAxis  = XAxis;
-static const CoordinateAxis NormalAxis   = YAxis;
-static const CoordinateAxis BinormalAxis = ZAxis;
+static constexpr CoordinateAxis TangentAxis  = XAxis;
+static constexpr CoordinateAxis NormalAxis   = YAxis;
+static constexpr CoordinateAxis BinormalAxis = ZAxis;
 
 //------------------------------------------------------------------------------
 //  Struct MatrixWorkspace
